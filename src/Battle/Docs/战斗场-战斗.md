# 战斗场战斗层文档

## 概述

战斗场战斗层是豆豆防御战游戏的核心战斗逻辑实现，负责处理战斗过程中的实体管理、战斗计算、状态更新等功能。战斗层与UI层完全分离，采用事件驱动的方式进行通信，确保逻辑与表现的解耦，同时支持无界面调试。

## 战斗层组成

战斗层由以下主要组件构成：

1. **战斗引擎**：整个战斗系统的入口，协调各个子系统
2. **战斗管理器**：负责整体战斗流程控制
3. **实体管理器**：管理所有战斗实体（英雄、豆豆、水晶）
4. **帧管理器**：处理逻辑帧和内部帧的更新
5. **伤害管理器**：计算和应用伤害
6. **技能管理器**：处理技能释放和效果
7. **波次管理器**：控制敌人波次生成
8. **事件管理器**：处理战斗事件分发
9. **随机管理器**：提供确定性随机数

## 战斗实体

战斗场中存在三种主要实体类型：

1. **英雄**：玩家控制的角色，具有生命值、魔法值、攻击力等属性
2. **豆豆**：敌人单位，有多种类型，各自具有不同的属性和行为
3. **水晶**：防御目标，玩家需要保护的核心

### 英雄实体

英雄是玩家在战斗中的代表，具有以下特性：

```typescript
export class Hero extends Entity {
  // 玩家ID
  private playerId: string;
  // 英雄ID
  private heroId: number;
  // 已学习的技能ID列表
  private learnedSkills: Set<number>;
  // 当前位置索引（1-5）
  private positionIndex: number;
  // 经验值
  private exp: number;
  // 等级
  private level: number;
  // 金币
  private gold: number;
  // 装备的物品ID列表
  private equippedItems: string[];
  
  // 英雄特有方法
  public getPlayerId(): string;
  public getHeroId(): number;
  public getLearnedSkills(): number[];
  public hasLearnedSkill(skillId: number): boolean;
  public learnSkill(skillId: number): boolean;
  public getPositionIndex(): number;
  public setPositionIndex(index: number): void;
  public addExp(amount: number): boolean;
  public getLevel(): number;
  public getGold(): number;
  public addGold(amount: number): void;
  public spendGold(amount: number): boolean;
  public getEquippedItems(): string[];
  public equipItem(itemId: string): boolean;
  public unequipItem(itemId: string): boolean;
}
```

### 豆豆实体

豆豆是战斗中的敌人单位，有多种类型，具有以下特性：

```typescript
export enum BeanType {
  NORMAL = 'normal',       // 普通豆
  FAST = 'fast',           // 快速豆
  STRONG = 'strong',       // 强壮豆
  POISON = 'poison',       // 毒豆
  EXPLOSIVE = 'explosive', // 炸弹豆
  FROST = 'frost',         // 冰霜豆
  ARMORED = 'armored',     // 铁甲豆
  RAGE = 'rage',           // 狂暴豆
  BOSS = 'boss'            // BOSS豆
}

export class Bean extends Entity {
  // 豆豆类型
  private beanType: BeanType;
  // 移动速度
  private moveSpeed: number;
  // 攻击范围
  private attackRange: number;
  // 攻击间隔（毫秒）
  private attackInterval: number;
  // 是否为特殊豆豆
  private isSpecial: boolean;
  // 所属波次索引
  private waveIndex: number;
  // 目标实体ID
  private targetId: string | null;
  // 上次攻击时间
  private lastAttackTime: number;
  
  // 豆豆特有方法
  public getBeanType(): BeanType;
  public getMoveSpeed(): number;
  public getAttackRange(): number;
  public getAttackInterval(): number;
  public isSpecialBean(): boolean;
  public getWaveIndex(): number;
  public getTargetId(): string | null;
  public setTargetId(targetId: string | null): void;
  public canAttack(): boolean;
  public performAttack(): void;
}
```

### 水晶实体

水晶是玩家需要保护的核心目标，具有以下特性：

```typescript
export enum CrystalState {
  NORMAL = 'normal',
  DAMAGED = 'damaged',
  CRITICAL = 'critical',
  DESTROYED = 'destroyed'
}

export class Crystal extends Entity {
  // 水晶状态
  private state: CrystalState;
  // 防御加成
  private defenseBonus: number;
  // 是否处于无敌状态
  private invulnerable: boolean;
  // 无敌状态开始时间
  private invulnerableStartTime: number;
  // 无敌状态持续时间（毫秒）
  private invulnerableDuration: number;
  // 伤害冷却时间（毫秒）
  private damageCooldown: number;
  // 上次受到伤害的时间
  private lastDamageTime: number;
  
  // 水晶特有方法
  public getState(): CrystalState;
  public getDefenseBonus(): number;
  public setDefenseBonus(bonus: number): void;
  public isInvulnerable(): boolean;
  public setInvulnerable(invulnerable: boolean, duration?: number): void;
  public updateState(): void;
}
```

## 战斗流程

战斗场景的战斗流程主要包括以下步骤：

1. **初始化**：创建战斗引擎，加载战斗参数
2. **开始战斗**：启动战斗循环，开始第一波敌人
3. **战斗循环**：
   - 更新逻辑帧和内部帧
   - 更新实体状态
   - 处理实体行为（移动、攻击等）
   - 检查波次状态，生成新的敌人
   - 检查胜利/失败条件
4. **结算**：战斗结束，计算战斗结果和奖励

### 战斗初始化

战斗初始化过程如下：

```typescript
// 创建战斗初始化参数
const battleParams: BattleInitParams = {
  crystal: {
    id: 1,
    name: '水晶',
    stats: {
      currentHP: 1000,
      maxHP: 1000
    },
    status: 'normal',
    positionIndex: 0,
    defenseBonus: 0
  },
  players: [
    {
      id: 'player1',
      name: '玩家1',
      hero: {
        id: 1,
        stats: {
          hp: 800,
          attack: 50,
          defense: 40,
          speed: 50,
          level: 1,
          exp: 0,
          gold: 0,
          equippedItems: [],
          learnedSkills: [1, 2]
        },
        position: 1
      }
    }
  ],
  level: {
    chapter: 1,
    stage: 1
  }
};

// 初始化战斗引擎
battleEngine.initBattle(battleParams, seed);

// 开始战斗
battleEngine.startBattle();
```

## 帧管理

战斗系统采用逻辑帧+内部帧的方式进行更新：

1. **逻辑帧**：每秒10帧，用于处理主要游戏逻辑
2. **内部帧**：每个逻辑帧包含5个内部帧（每秒50帧），用于处理细粒度的实体移动和碰撞检测

```typescript
export class FrameManager {
  // 逻辑帧率（每秒帧数）
  private logicFrameRate: number = 10;
  // 内部帧率（每个逻辑帧的内部帧数）
  private internalFramesPerLogicFrame: number = 5;
  // 当前逻辑帧号
  private currentLogicFrame: number = 0;
  // 当前内部帧号
  private currentInternalFrame: number = 0;
  // 逻辑帧时间间隔（毫秒）
  private logicFrameInterval: number;
  // 内部帧时间间隔（毫秒）
  private internalFrameInterval: number;
  // 上次更新时间
  private lastUpdateTime: number = 0;
  // 累积时间（用于帧更新）
  private accumulatedTime: number = 0;
  
  // 帧更新方法
  public update(currentTime: number): FrameUpdateResult;
}
```

## 伤害计算

伤害计算是战斗系统的核心部分，考虑了攻击力、防御力、暴击、闪避等因素：

```typescript
export class DamageManager {
  // 应用伤害
  public applyDamage(
    source: Entity | null,
    target: Entity,
    amount: number,
    type: DamageType,
    options: DamageOptions = {}
  ): DamageResult {
    // 检查目标是否可以受到伤害
    if (!target.isAlive() || target.isInvulnerable()) {
      return { success: false, actualAmount: 0, isCritical: false };
    }
    
    // 获取基础伤害
    let finalAmount = amount;
    
    // 应用防御力减免
    if (!options.ignoreDefense) {
      const defense = target.getStat('defense');
      finalAmount = this.calculateDamageReduction(finalAmount, defense);
    }
    
    // 检查闪避
    if (options.evadeCheck && this.checkEvade(target)) {
      return { success: false, actualAmount: 0, isCritical: false, evaded: true };
    }
    
    // 检查暴击
    const isCritical = this.checkCritical(options.criticalRate || 0);
    if (isCritical) {
      finalAmount = Math.floor(finalAmount * 1.5);
    }
    
    // 应用最终伤害
    const actualAmount = target.takeDamage(finalAmount, type, source);
    
    return {
      success: true,
      actualAmount,
      isCritical,
      evaded: false
    };
  }
}
```

## 波次管理

波次管理器负责控制敌人的生成和波次进度：

```typescript
export class WaveManager {
  // 当前波次索引
  private currentWaveIndex: number = -1;
  // 总波次数
  private totalWaves: number = 0;
  // 波次配置
  private waveConfigs: WaveConfig[] = [];
  // 当前波次状态
  private currentWaveState: WaveState = WaveState.IDLE;
  // 当前波次开始时间
  private currentWaveStartTime: number = 0;
  // 当前波次剩余敌人数量
  private remainingEnemies: number = 0;
  
  // 开始下一波
  public startNextWave(): boolean;
  // 生成敌人
  public spawnEnemies(): void;
  // 检查波次是否完成
  public checkWaveCompletion(): boolean;
}
```

## 事件系统

事件系统是战斗层与UI层通信的桥梁，主要事件包括：

1. **实体事件**：创建、移动、状态变化、死亡等
2. **战斗事件**：开始、暂停、结束等
3. **波次事件**：波次开始、波次完成等
4. **技能事件**：技能使用、冷却更新等

```typescript
export class EventManager {
  // 事件监听器映射
  private listeners: Map<string, Set<EventListener>> = new Map();
  
  // 注册事件监听器
  public on(eventType: string, listener: EventListener): void;
  // 移除事件监听器
  public off(eventType: string, listener: EventListener): void;
  // 触发事件
  public emit(eventType: string, eventData?: any): void;
}
```

## 战斗指令

玩家可以通过发送战斗指令与战斗系统交互，主要指令包括：

1. **移动指令**：改变英雄位置
2. **技能指令**：使用技能
3. **物品指令**：使用物品
4. **学习技能指令**：学习新技能

```typescript
export interface BattleCommand {
  type: string;
  playerId: string;
  timestamp: number;
}

export interface CastSkillCommand extends BattleCommand {
  type: 'cast_skill';
  skillId: number;
  targetPosition?: Vector2D;
  targetEntityId?: string;
}

export interface ChangePositionCommand extends BattleCommand {
  type: 'change_position';
  newPosition: number;
}

export interface UseItemCommand extends BattleCommand {
  type: 'use_item';
  itemId: string;
  targetEntityId?: string;
}

export interface LearnSkillCommand extends BattleCommand {
  type: 'learn_skill';
  skillId: number;
}
```

## 战斗结果

战斗结束后，会生成战斗结果，包括：

1. **胜利/失败**：战斗的最终结果
2. **统计数据**：击杀数、伤害量、生存时间等
3. **奖励**：经验值、金币等

```typescript
export enum BattleResult {
  NONE = 'none',
  VICTORY = 'victory',
  DEFEAT = 'defeat',
  DRAW = 'draw'
}

export interface BattleStats {
  // 战斗时长（毫秒）
  duration: number;
  // 总伤害量
  totalDamage: number;
  // 击杀数
  kills: number;
  // 水晶剩余生命值
  crystalRemainingHp: number;
  // 英雄统计
  heroStats: {
    id: string;
    damage: number;
    kills: number;
    deaths: number;
    skillsUsed: number;
  }[];
}
```

## 回放系统

战斗系统支持回放功能，可以记录战斗过程中的关键事件和指令，用于后续回放：

```typescript
export class ReplayManager {
  // 回放状态
  private state: ReplayState = ReplayState.IDLE;
  // 回放数据
  private replayData: BattleReplayData | null = null;
  // 当前回放事件索引
  private currentEventIndex: number = 0;
  // 回放开始时间
  private replayStartTime: number = 0;
  
  // 开始记录回放
  public startRecording(battleParams: BattleInitParams, seed: number): void;
  // 停止记录回放
  public stopRecording(): BattleReplayData | null;
  // 开始回放
  public startReplay(replayData: BattleReplayData): void;
  // 暂停回放
  public pauseReplay(): void;
  // 恢复回放
  public resumeReplay(): void;
  // 停止回放
  public stopReplay(): void;
}
```

## 性能优化

为了确保战斗系统的高效运行，采取了以下性能优化措施：

1. **实体池**：使用对象池管理频繁创建和销毁的实体
2. **空间分区**：使用网格或四叉树进行空间分区，优化碰撞检测
3. **事件批处理**：将多个事件合并处理，减少事件分发开销
4. **延迟计算**：对不需要立即计算的逻辑进行延迟处理
5. **确定性随机**：使用确定性随机数生成器，确保回放的一致性

## 战斗调试

战斗系统支持无界面调试，可以通过以下方式进行：

```typescript
// 设置日志级别
logger.setLogLevel(LogLevel.DEBUG);

// 启用控制台输出
logger.setConsoleOutput(true);

// 启用文件输出
logger.setFileOutput(true, './battle_log.txt');

// 运行测试脚本
// ts-node src/Battle/Test/BattleTest.ts
```

## 后续优化方向

1. **AI决策系统**：优化豆豆的AI行为，使其更智能
2. **技能系统扩展**：增加更多技能类型和效果
3. **Buff系统完善**：增加更多状态效果和交互
4. **多人战斗支持**：支持多玩家协同战斗
5. **战斗平衡性调整**：根据数据分析调整战斗参数
