# 战斗场景文档

## 概述

战斗场景是豆豆防御战游戏的核心场景，负责展示战斗过程并处理玩家交互。战斗场景由两个主要视图层组成：战斗视图层和UI视图层。这两个视图层在功能和实现上有明确的区分，确保了良好的用户体验和代码结构。

## 战斗视图与UI视图的区分

### 功能区分

| 特性 | 战斗视图 | UI视图 |
|------|---------|--------|
| 主要职责 | 渲染战斗实体和效果 | 显示游戏状态和控制元素 |
| 坐标系统 | 世界坐标系统 (0-3000) | 屏幕坐标系统 (0-屏幕尺寸) |
| 摄像机行为 | 跟随英雄移动 | 固定位置不移动 |
| 深度层级 | WORLD_* 层级 | UI_* 层级 |
| 交互方式 | 实体交互 | 按钮和控制元素交互 |

### 技术实现区分

1. **摄像机处理**：
   - 战斗视图使用主摄像机，会跟随英雄移动
   - UI视图元素设置`scrollFactor=0`，不受摄像机移动影响

2. **坐标转换**：
   - 战斗视图需要世界坐标和屏幕坐标的转换
   - UI视图直接使用屏幕坐标

3. **深度管理**：
   - 战斗视图元素使用`WORLD_*`层级常量
   - UI视图元素使用`UI_*`层级常量，确保显示在战斗视图之上

4. **事件处理**：
   - 战斗视图处理战斗逻辑相关事件
   - UI视图处理用户交互相关事件

## 战斗视图层

战斗视图层负责将战斗逻辑转换为可视化表现，包括实体渲染、动画效果、摄像机控制等。

### 主要组件

1. **实体渲染器 (EntityRenderer)**：
   ```typescript
   export class EntityRenderer {
     // 实体显示对象
     private entitySprites: Map<string, Phaser.GameObjects.Sprite>;
     // 伤害数字组
     private damageTexts: Phaser.GameObjects.Group;
     // 屏幕外指示器管理器
     private offscreenIndicatorManager: any = null;
     
     // 创建实体精灵
     public createEntitySprite(event: EntityCreatedEvent): void {
       // 转换为屏幕坐标
       const screenPos = this.cameraController.worldToScreenPosition(position);
       
       // 创建精灵
       let sprite: Phaser.GameObjects.Text;
       switch (entityType) {
         case 'hero':
           sprite = this.scene.add.text(screenPos.x, screenPos.y, '🧙', {
             fontSize: `${heroSize}px`
           });
           sprite.setDepth(DepthLayers.WORLD_ENTITY);
           break;
         // ...其他实体类型
       }
     }
     
     // 更新实体位置
     public updateEntityPosition(entityId: string, position: Vector2D, animate: boolean): void {
       // 转换为屏幕坐标
       const screenPos = this.cameraController.worldToScreenPosition(position);
       
       // 更新精灵位置
       if (animate) {
         // 使用动画移动精灵
         this.scene.tweens.add({
           targets: sprite,
           x: screenPos.x,
           y: screenPos.y,
           duration: 100,
           ease: 'Linear'
         });
       } else {
         // 直接设置位置
         sprite.x = screenPos.x;
         sprite.y = screenPos.y;
       }
     }
   }
   ```

2. **摄像机控制器 (CameraController)**：
   ```typescript
   export class CameraController {
     // 相机配置
     private zoomFactor: number = 2.0;
     private worldCenterX: number = 1500;
     private worldCenterY: number = 1500;
     private worldSize: number = 3000;
     
     // 世界坐标转屏幕坐标
     public worldToScreenPosition(position: Vector2D): Vector2D {
       // 计算相对于世界中心的偏移
       const offsetX = position.x - this.worldCenterX;
       const offsetY = position.y - this.worldCenterY;
       
       // 应用缩放并转换到屏幕坐标
       return {
         x: (screenWidth / 2) + (offsetX * screenWidth / (this.worldSize / this.zoomFactor)),
         y: (screenHeight / 2) + (offsetY * screenHeight / (this.worldSize / this.zoomFactor))
       };
     }
     
     // 聚焦到指定位置
     public focusOnPosition(position: Vector2D, duration: number = 300): void {
       // 设置主相机跟随目标
       this.scene.cameras.main.pan(
         screenPos.x,
         screenPos.y,
         duration,
         'Sine.easeOut'
       );
     }
   }
   ```

3. **技能效果视图 (SkillEffectView)**：
   ```typescript
   export class SkillEffectView {
     // 播放技能效果
     public playSkillEffect(
       skillId: string,
       sourcePosition: Vector2D,
       targetPosition: Vector2D,
       onComplete?: () => void
     ): void {
       // 获取技能视觉配置
       const config = getSkillVisualConfig(skillId);
       
       // 根据技能类型选择不同的效果
       switch (visualEffect.type) {
         case SkillType.DAMAGE:
           this.playDamageEffect(visualEffect, sourcePosition, targetPosition, onComplete);
           break;
         // ...其他技能类型
       }
     }
   }
   ```

4. **屏幕外指示器管理器 (OffscreenIndicatorManager)**：
   ```typescript
   export class OffscreenIndicatorManager {
     // 更新指示器
     public updateIndicator(entityId: string, worldPosition: Vector2D, emoji: string, isVisible: boolean): void {
       // 如果实体在屏幕内可见，移除指示器
       if (isVisible) {
         this.removeIndicator(entityId);
         return;
       }
       
       // 如果实体在屏幕外，创建或更新指示器
       this.createOrUpdateIndicator(entityId, worldPosition, emoji);
     }
     
     // 计算指示器位置
     private calculateIndicatorPosition(worldPosition: Vector2D): Vector2D {
       // 转换为屏幕坐标
       const screenPos = this.cameraController.worldToScreenPosition(worldPosition);
       
       // 计算方向向量 (从屏幕中心到实体)
       const centerX = screenWidth / 2;
       const centerY = screenHeight / 2;
       const dx = screenPos.x - centerX;
       const dy = screenPos.y - centerY;
       
       // 计算角度和屏幕边缘的交点
       // ...
     }
   }
   ```

### 战斗视图层级结构

战斗视图使用以下层级结构来管理不同元素的显示顺序：

```typescript
export enum DepthLayers {
  BACKGROUND = 0,        // 背景层
  WORLD_GROUND = 10,     // 地面层
  WORLD_ENTITY = 20,     // 实体层
  WORLD_EFFECT = 30,     // 效果层
  WORLD_PROJECTILE = 40, // 投射物层
  WORLD_OVERLAY = 50,    // 世界覆盖层
  // UI层级从100开始
}
```

## UI视图层

UI视图层负责显示游戏状态和提供用户交互界面，包括状态栏、波次指示器、技能按钮等。

### 主要组件

1. **UI管理器 (UIManager)**：
   ```typescript
   export class UIManager {
     // UI元素
     private statusBar!: Phaser.GameObjects.Container;
     private waveIndicator!: Phaser.GameObjects.Text;
     private pauseButton!: Phaser.GameObjects.Text;
     private skillButtonsContainer!: Phaser.GameObjects.Container;
     private skillUIComponents: Map<string, SkillUIComponent> = new Map();
     
     // 创建UI元素
     private createUI(): void {
       // 创建状态栏
       this.createStatusBar();
       
       // 创建波次指示器
       this.createWaveIndicator();
       
       // 创建暂停按钮
       this.createPauseButton();
       
       // 创建技能按钮
       this.createSkillButtons();
       
       // 固定UI元素，使其不受摄像机移动影响
       this.fixUIElements();
     }
     
     // 固定UI元素
     private fixUIElements(): void {
       // 设置各个UI元素的scrollFactor为0，确保它们不随摄像机移动
       this.statusBar.setScrollFactor(0);
       this.statusBar.setDepth(DepthLayers.UI_ELEMENT);
       
       this.waveIndicator.setScrollFactor(0);
       this.waveIndicator.setDepth(DepthLayers.UI_ELEMENT);
       
       this.pauseButton.setScrollFactor(0);
       this.pauseButton.setDepth(DepthLayers.UI_ELEMENT);
       
       this.skillButtonsContainer.setScrollFactor(0);
       this.skillButtonsContainer.setDepth(DepthLayers.UI_ELEMENT);
     }
   }
   ```

2. **技能UI组件 (SkillUIComponent)**：
   ```typescript
   export class SkillUIComponent {
     // 更新冷却时间
     public updateCooldown(currentCooldown: number, maxCooldown: number): void {
       this.currentCooldown = currentCooldown;
       this.maxCooldown = maxCooldown;
       
       if (currentCooldown > 0) {
         // 显示冷却遮罩和文本
         this.cooldownOverlay.visible = true;
         this.cooldownText.visible = true;
         this.cooldownText.setText(Math.ceil(currentCooldown).toString());
         
         // 更新冷却遮罩填充比例
         const ratio = currentCooldown / maxCooldown;
         this.updateCooldownMask(ratio);
       } else {
         // 隐藏冷却遮罩和文本
         this.cooldownOverlay.visible = false;
         this.cooldownText.visible = false;
       }
     }
   }
   ```

### UI视图层级结构

UI视图使用以下层级结构来管理不同元素的显示顺序：

```typescript
export enum DepthLayers {
  // 战斗层级从0开始
  UI_BACKGROUND = 100,   // UI背景层
  UI_ELEMENT = 110,      // UI元素层
  UI_OVERLAY = 120,      // UI覆盖层
  UI_TOOLTIP = 130,      // UI提示层
  UI_MODAL = 140,        // UI模态层
  UI_NOTIFICATION = 150  // UI通知层
}
```

## 战斗场景视图的协调

战斗场景视图 (BattleSceneView) 负责协调战斗视图和UI视图，确保它们正确交互：

```typescript
export class BattleSceneView {
  private scene: Phaser.Scene;
  private battleEngine: BattleEngine;
  private eventManager: EventManager;

  // 组件
  private entityRenderer: EntityRenderer;
  private uiManager: UIManager;
  private cameraController: CameraController;
  private skillEffectView: SkillEffectView;
  private eventHandlers: EventHandlers;
  private touchController: TouchController;
  private offscreenIndicatorManager: OffscreenIndicatorManager;
  
  // 构造函数
  constructor(scene: Phaser.Scene, battleEngine: BattleEngine) {
    // 初始化各个组件
    this.cameraController = new CameraController(scene);
    this.skillEffectView = new SkillEffectView(scene);
    this.entityRenderer = new EntityRenderer(scene, this.cameraController);
    this.offscreenIndicatorManager = new OffscreenIndicatorManager(scene, this.cameraController);
    this.uiManager = new UIManager(scene, () => this.battleEngine.pause(), () => this.battleEngine.resume());
    this.touchController = new TouchController(scene, battleEngine);
    
    // 注册UI元素到相机控制器
    this.registerUIElementsWhenReady();
    
    // 初始化事件处理器
    this.eventHandlers = new EventHandlers(
      this.entityRenderer,
      this.uiManager,
      this.cameraController,
      this.skillEffectView,
      this.eventManager,
      this.battleEngine
    );
  }
  
  // 注册UI元素
  private registerUIElementsWhenReady(): void {
    // 获取UI元素
    const uiElements = this.uiManager.getAllUIElements();
    
    // 注册到相机控制器
    this.cameraController.registerUIElements(uiElements);
  }
  
  // 更新方法
  public update(time: number, delta: number): void {
    // 更新实体位置和状态
    this.updateEntities();
    
    // 更新UI
    this.updateUI();
    
    // 更新技能冷却
    this.uiManager.updateSkillCooldowns(delta);
    
    // 更新触摸控制器
    this.touchController.update(time, delta);
  }
}
```

## 事件系统

战斗场景使用事件系统来处理战斗逻辑和视图之间的通信：

```typescript
export class EventHandlers {
  // 注册事件监听器
  private registerEventListeners(): void {
    // 战斗引擎到视图层的实体事件
    this.eventManager.on(EventType.ENTITY_CREATED, this.onEntityCreated.bind(this));
    this.eventManager.on(EventType.ENTITY_MOVED, this.onEntityMoved.bind(this));
    this.eventManager.on(EventType.ENTITY_STATE_CHANGED, this.onEntityStateChanged.bind(this));
    
    // 战斗引擎到视图层的技能事件
    this.eventManager.on(EventType.SKILL_USED, this.onSkillUsed.bind(this));
    this.eventManager.on(EventType.SKILL_COOLDOWN_UPDATED, this.onSkillCooldownUpdated.bind(this));
    
    // 战斗引擎到视图层的波次事件
    this.eventManager.on(EventType.WAVE_STARTED, this.onWaveStarted.bind(this));
    this.eventManager.on(EventType.WAVE_COMPLETED, this.onWaveCompleted.bind(this));
    
    // 战斗引擎到视图层的游戏事件
    this.eventManager.on(EventType.GAME_OVER, this.onGameOver.bind(this));
  }
  
  // 实体创建事件处理
  private onEntityCreated(event: EntityCreatedEvent): void {
    // 创建实体精灵
    this.entityRenderer.createEntitySprite(event);
  }
  
  // 实体移动事件处理
  private onEntityMoved(event: EntityMovedEvent): void {
    // 更新实体位置
    this.entityRenderer.updateEntityPosition(event.entityId, event.position, true);
    
    // 如果是英雄，聚焦摄像机
    if (event.entityId.startsWith('hero_')) {
      this.cameraController.focusOnPosition(event.position);
    }
  }
}
```

## 屏幕适配

战斗场景支持不同分辨率的设备，主要通过以下方式实现：

1. **相对尺寸**：实体大小基于屏幕宽度的百分比
   ```typescript
   const heroSize = Math.min(48, Math.max(32, screenWidth * 0.09));
   const beanSize = Math.min(32, Math.max(24, screenWidth * 0.06));
   ```

2. **自适应布局**：UI元素位置基于屏幕尺寸动态计算
   ```typescript
   this.statusBarBg = this.scene.add.rectangle(
     this.scene.cameras.main.width / 2,
     40,
     this.scene.cameras.main.width - 20,
     70,
     0x000000,
     0.7
   );
   ```

3. **坐标转换**：使用坐标转换确保实体在不同屏幕尺寸下正确显示
   ```typescript
   const screenPos = this.cameraController.worldToScreenPosition(position);
   ```

## 总结

战斗场景通过明确区分战斗视图和UI视图，实现了以下优势：

1. **清晰的职责分离**：战斗视图负责渲染战斗实体和效果，UI视图负责显示游戏状态和控制元素
2. **独立的摄像机控制**：战斗视图跟随英雄移动，UI视图保持固定位置
3. **统一的坐标转换**：提供了世界坐标和屏幕坐标之间的转换方法
4. **层级管理**：使用深度层级确保元素正确显示
5. **事件驱动**：通过事件系统实现战斗逻辑和视图之间的通信
6. **屏幕适配**：支持不同分辨率的设备

这种设计使得战斗场景能够提供流畅的游戏体验，同时保持代码的可维护性和可扩展性。
