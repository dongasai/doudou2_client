# 2025-05-06 修复BUG

## 移除主场景背景

### 问题描述
用户反馈背景不应该影响UI元素的可见性，UI应该独立于背景正常显示。当前主菜单场景的渐变背景和装饰性豆豆可能会影响UI元素的可见性，特别是在某些颜色组合下。

### 解决方案
修改`MainMenuScene.ts`文件中的`createBackground`方法，将渐变背景和装饰性豆豆替换为纯黑色背景。

### 修改的文件
`src/Scenes/MainMenuScene.ts`
- 移除渐变背景和装饰性豆豆
- 使用纯黑色背景替代

### 效果
修改后，主菜单场景的背景变为纯黑色，不再有渐变效果和装饰性豆豆。这样可以确保UI元素在任何情况下都能清晰可见，不受背景颜色的影响。

### 后续工作
1. 考虑为UI元素添加适当的描边或阴影，以确保它们在任何背景下都能清晰可见。
2. 考虑添加一个设置选项，允许用户自定义背景颜色或选择是否显示背景。

## 设置场景帧率

### 问题描述
用户希望能够单独设置不同场景的帧率，以优化性能和用户体验。特别是，战斗场景需要较高的帧率以确保流畅的游戏体验，而其他场景可以使用较低的帧率以节省资源。

### 解决方案
修改各个场景的`create`方法，设置不同的帧率：
- 战斗场景：30fps
- 其他场景（主菜单、关卡选择、英雄选择、百科等）：10fps

### 修改的文件
1. `src/Scenes/MainMenuScene.ts`
   - 设置帧率为2fps

2. `src/Scenes/LevelSelectScene.ts`
   - 设置帧率为2fps

3. `src/Scenes/HeroSelectScene.ts`
   - 设置帧率为2fps

4. `src/Scenes/BattleScene.ts`
   - 设置帧率为30fps

5. `src/Scenes/EncyclopediaBeansScene.ts`
   - 设置帧率为2fps

6. `src/Scenes/EncyclopediaHeroesScene.ts`
   - 设置帧率为2fps

### 效果
修改后，不同场景使用不同的帧率，优化了性能和用户体验。战斗场景使用30fps确保流畅的游戏体验，其他场景使用10fps节省资源。

### 后续工作
1. 考虑添加一个设置选项，允许用户自定义不同场景的帧率。
2. 考虑根据设备性能自动调整帧率，以适应不同的硬件环境。

## 修复豆豆不能移动/攻击的问题

### 问题描述
用户反馈在战斗场景中，豆豆不能移动和攻击，导致游戏无法正常进行。同时，日志中出现错误：`[ERROR] 事件处理器异常: entityMoved - {}`，表明在处理实体移动事件时出现了异常。

### 问题分析
通过代码分析，发现以下几个可能的原因：

1. **豆豆状态问题**：豆豆的移动和攻击是基于状态的（`BeanState`），如果豆豆的状态没有正确设置为`MOVE`或`ATTACK`，它们就不会执行相应的行为。

2. **目标设置问题**：豆豆需要有一个有效的目标（通过`setTarget`方法设置），如果没有目标，豆豆就不会移动或攻击。

3. **实体更新问题**：豆豆的更新是通过`EntityManager.updateAllEntities`方法调用`Bean.update`方法实现的，如果这个更新流程有问题，豆豆就不会执行移动和攻击行为。

4. **事件传递问题**：豆豆的创建和状态变化需要通过事件系统传递到视图层，如果事件没有正确触发或处理，豆豆在视图上就不会显示移动或攻击。特别是，`entityMoved`事件的数据结构与`EntityMovedEvent`接口不匹配，导致事件处理器异常。

5. **渲染问题**：即使豆豆在逻辑上正确移动和攻击，如果渲染层没有正确更新，用户也不会看到豆豆的移动和攻击效果。

### 解决方案

1. **增强日志记录**：在关键方法中添加详细的日志记录，以便更好地追踪豆豆的状态和行为。

2. **修复豆豆状态管理**：
   - 在`Bean.update`方法中，确保豆豆在空闲状态但有目标时自动切换到移动状态
   - 添加对死亡状态的处理，确保死亡的豆豆不执行任何行为

3. **改进目标设置**：
   - 在`BattleManager.createBeanFromWaveManager`方法中，添加更详细的日志记录，确保豆豆正确设置了目标
   - 在`Bean.moveToTarget`和`Bean.attackTarget`方法中，添加对目标不存在情况的处理

4. **增强实体更新机制**：
   - 修改`EntityManager.updateAllEntities`方法，使其能够检测实体位置变化并触发相应的事件
   - 修改`BattleManager.onFrameUpdate`方法，确保在更新实体时传递事件管理器

5. **改进事件传递**：
   - 确保实体移动事件能够正确触发和处理，使视图层能够及时更新豆豆的位置
   - 使用`EventType`枚举常量而不是字符串来触发事件，提高代码的可维护性和避免拼写错误
   - 修复`entityMoved`事件数据结构，使其与`EntityMovedEvent`接口匹配，解决事件处理器异常问题

### 修改的文件
1. `src/Battle/Core/BattleManager.ts`
   - 增强豆豆创建和目标设置的日志记录
   - 修改`onFrameUpdate`方法，传递事件管理器

2. `src/Battle/Entities/Bean.ts`
   - 改进`update`方法，增强状态管理
   - 改进`moveToTarget`方法，增强目标处理和日志记录
   - 改进`attackTarget`方法，增强目标处理和日志记录

3. `src/Battle/Core/EntityManager.ts`
   - 修改`updateAllEntities`方法，检测实体位置变化并触发事件
   - 导入并使用`EventType`枚举常量来触发事件
   - 修复`entityMoved`事件数据结构，确保与`EntityMovedEvent`接口匹配

### 效果
修复后，豆豆能够正确移动和攻击，游戏可以正常进行。同时，通过增强的日志记录，可以更好地追踪豆豆的状态和行为，便于后续调试和优化。

### 后续工作
1. 考虑进一步优化豆豆的AI逻辑，使其行为更加智能和自然
2. 考虑添加更多的豆豆类型和行为模式，增加游戏的多样性和挑战性
3. 考虑优化事件系统，减少不必要的事件触发，提高性能

## 修复水晶无法受到伤害的问题

### 问题描述
在战斗场景中，豆豆攻击水晶时，水晶的生命值没有减少。日志显示豆豆正在攻击水晶，但水晶的生命值没有变化。

### 问题分析
通过分析代码，发现以下几个问题：
1. 豆豆的攻击逻辑没有正确记录和显示伤害结果
2. 水晶的`takeDamage`方法没有正确处理伤害
3. 水晶的伤害冷却时间太长，导致连续攻击无效
4. 实体的基础`takeDamage`方法缺少详细的日志记录

### 解决方案
1. 修改`Bean.ts`文件中的`attackTarget`方法，增加详细的日志记录，包括目标生命值变化
2. 修改`Crystal.ts`文件中的`takeDamage`方法，增加详细的日志记录，并确保伤害正确应用
3. 在`Crystal.ts`文件中添加`setDamageCooldown`方法，允许调整伤害冷却时间
4. 修改`BattleManager.ts`文件中的`createCrystal`方法，设置较短的伤害冷却时间
5. 修改`DamageManager.ts`文件中的`applyDamage`方法，增加详细的日志记录
6. 修改`Entity.ts`文件中的`takeDamage`方法，增加详细的日志记录

### 修改的文件
1. `src/Battle/Entities/Bean.ts`
   - 增强`attackTarget`方法，记录目标生命值变化
   - 添加更详细的日志记录

2. `src/Battle/Entities/Crystal.ts`
   - 增强`takeDamage`方法，记录生命值变化
   - 添加`setDamageCooldown`方法，允许调整伤害冷却时间
   - 添加更详细的日志记录

3. `src/Battle/Core/BattleManager.ts`
   - 增强`createCrystal`方法，设置较短的伤害冷却时间
   - 添加更详细的日志记录
   - 设置水晶的防御属性

4. `src/Battle/Core/DamageManager.ts`
   - 增强`applyDamage`方法，记录目标生命值变化
   - 添加更详细的日志记录

5. `src/Battle/Entities/Entity.ts`
   - 增强`takeDamage`方法，记录生命值变化
   - 添加更详细的日志记录

### 效果
修改后，豆豆攻击水晶时，水晶的生命值会正确减少，并且日志中会显示详细的伤害信息和生命值变化。

### 后续工作
1. 考虑添加水晶受伤的视觉效果，使玩家更容易看到水晶受到伤害
2. 考虑添加水晶生命值的UI显示，使玩家能够直观地看到水晶的生命值变化
3. 考虑优化伤害计算逻辑，使伤害更加平衡

## 修复水晶生命值变化不显示在视图层的问题

### 问题描述
虽然水晶的生命值在逻辑层已经正确减少（日志显示从964减少到956），但是在视图层没有更新，玩家看不到水晶生命值的变化。

### 问题分析
通过分析代码，发现以下几个问题：
1. 水晶的生命值变化没有触发`EntityStatsChanged`事件
2. 即使触发了事件，视图层也没有正确处理该事件
3. 缺少水晶受伤的视觉反馈

### 解决方案
1. 修改`Crystal.ts`文件，添加`setEventManager`方法，允许设置事件管理器
2. 修改`Crystal.ts`文件中的`takeDamage`方法，触发`EntityStatsChanged`事件
3. 修改`BattleManager.ts`文件中的`createCrystal`方法，设置水晶的事件管理器
4. 修改`EventHandlers.ts`文件中的`onEntityStatsChanged`方法，处理水晶的生命值变化
5. 添加水晶受伤的视觉效果，包括颜色变化和伤害数字显示

### 修改的文件
1. `src/Battle/Entities/Crystal.ts`
   - 添加`setEventManager`方法
   - 修改`takeDamage`方法，触发`EntityStatsChanged`事件

2. `src/Battle/Core/BattleManager.ts`
   - 修改`createCrystal`方法，设置水晶的事件管理器

3. `src/Battle/View/EventHandlers.ts`
   - 修改`onEntityStatsChanged`方法，处理水晶的生命值变化
   - 添加水晶受伤的视觉效果

### 效果
修改后，当水晶受到伤害时，不仅在逻辑层正确减少生命值，还会在视图层显示伤害数字和颜色变化，使玩家能够直观地看到水晶受到伤害。

### 后续工作
1. 考虑添加水晶生命值条，使玩家能够更直观地看到水晶的生命值变化
2. 考虑添加水晶破碎效果，使水晶受到伤害时有更明显的视觉反馈
3. 考虑添加水晶生命值低于一定百分比时的警告效果，提醒玩家注意保护水晶

## 修复战斗场景UI中水晶生命值不更新的问题

### 问题描述
虽然水晶的生命值在逻辑层已经正确减少，并且视图层也显示了伤害效果，但是战斗场景UI中的HP数值没有更新，玩家无法看到水晶生命值的变化。

### 问题分析
通过分析代码，发现以下几个问题：
1. 水晶生命值变化事件触发后，只更新了本地变量，没有真正更新到`BattleManager`中的状态
2. UI层没有正确读取和显示水晶的生命值
3. `BattleEngine`缺少获取`BattleManager`的方法

### 解决方案
1. 修改`BattleManager.ts`文件，添加`updateCrystalStats`方法，用于更新水晶状态
2. 修改`BattleManager.ts`文件中的`registerEventListeners`方法，添加对`entityStatsChanged`事件的监听
3. 修改`EventHandlers.ts`文件中的`onEntityStatsChanged`方法，使用`BattleManager`的`updateCrystalStats`方法来更新水晶状态
4. 修改`BattleEngine.ts`文件，添加`getBattleManager`方法，用于获取`BattleManager`
5. 修改`BattleSceneView.ts`文件中的`updateUI`方法，确保它能够正确显示水晶的生命值

### 修改的文件
1. `src/Battle/Core/BattleManager.ts`
   - 添加`updateCrystalStats`方法，用于更新水晶状态
   - 修改`registerEventListeners`方法，添加对`entityStatsChanged`事件的监听

2. `src/Battle/View/EventHandlers.ts`
   - 修改`onEntityStatsChanged`方法，使用`BattleManager`的`updateCrystalStats`方法来更新水晶状态

3. `src/Battle/Core/BattleEngine.ts`
   - 添加`getBattleManager`方法，用于获取`BattleManager`

4. `src/Battle/View/BattleSceneView.ts`
   - 修改`updateUI`方法，确保它能够正确显示水晶的生命值

### 效果
修改后，当水晶受到伤害时，不仅在逻辑层正确减少生命值，在视图层显示伤害效果，还会在战斗场景UI中更新HP数值，使玩家能够直观地看到水晶生命值的变化。

### 后续工作
1. 考虑添加专门的水晶生命值UI，与英雄生命值分开显示
2. 考虑添加水晶生命值百分比显示，使玩家能够更直观地了解水晶的生命状态
3. 考虑优化UI更新逻辑，减少不必要的更新，提高性能

## 修复水晶生命值变化事件触发失败的问题

### 问题描述
在修复水晶生命值变化不显示在视图层的问题后，发现水晶在尝试触发属性变化事件时失败，日志显示错误：`[ERROR] 水晶crystal_1触发属性变化事件失败: - {}`。

### 问题分析
通过分析代码，发现以下几个问题：
1. 水晶使用`require`导入`EventType`时出错
2. `EventHandlers.ts`文件中没有注册字符串版本的`entityStatsChanged`事件
3. `EventHandlers.ts`文件中存在一些未使用的变量和方法引用错误

### 解决方案
1. 修改`Crystal.ts`文件中的事件触发代码，使用字符串事件类型而不是导入`EventType`
2. 修改`EventHandlers.ts`文件，添加字符串版本的`entityStatsChanged`事件监听
3. 修复`EventHandlers.ts`文件中的未使用变量和方法引用错误
4. 修改`UIManager.ts`文件，添加`getScene`方法，用于获取场景引用

### 修改的文件
1. `src/Battle/Entities/Crystal.ts`
   - 修改事件触发代码，使用字符串事件类型
   - 添加时间戳到事件数据

2. `src/Battle/View/EventHandlers.ts`
   - 添加字符串版本的`entityStatsChanged`事件监听
   - 修复未使用变量和方法引用错误
   - 修改`onGameOver`方法，使用正确的场景引用

3. `src/Battle/View/UIManager.ts`
   - 添加`getScene`方法，用于获取场景引用

### 效果
修改后，水晶能够正确触发属性变化事件，视图层能够正确处理该事件，玩家可以看到水晶受到伤害时的视觉反馈。

### 后续工作
1. 考虑优化事件系统，使用更统一的事件类型定义
2. 考虑添加更多的视觉反馈，如水晶受到伤害时的震动效果
3. 考虑添加水晶生命值UI，使玩家能够更直观地看到水晶的生命值变化

## 修复战斗界面状态栏问题

### 问题描述
战斗界面中的状态栏显示不清晰，UI元素之间存在重叠问题。从截图中可以看到，状态栏的文本显示不清晰，背景透明度不够，波次指示器位置不合理。

### 修复方案
1. **状态栏改进**：
   - 移除水晶图标和英雄头像，节省空间
   - 增加状态栏背景的不透明度，从0.7提高到0.8
   - 增加生命值条和魔法值条的高度，从12px增加到15px
   - 增加文本大小，并添加描边，提高可读性

2. **波次指示器改进**：
   - 添加黑色半透明背景，提高可读性
   - 增加字体大小和描边粗细
   - 调整位置，使其更加明显
   - 设置文本居中对齐

3. **暂停按钮调整**：
   - 将暂停按钮下移，避免与波次指示器重叠
   - 保持原有样式和功能

### 修改的文件
1. `src/Battle/View/UIManager.ts`
   - 修改 `createStatusBar` 方法，移除水晶图标和英雄头像
   - 修改 `updateStatusBar` 方法，更新元素索引
   - 修改 `createWaveIndicator` 方法，添加背景并调整样式
   - 修改 `createPauseButton` 方法，调整位置
   - 修改 `destroy` 方法，添加错误处理
   - 移除未使用的 `uiContainer` 变量

## 修复游戏结果判断逻辑

### 问题描述
当水晶被杀死时，游戏显示了胜利，但实际上应该显示失败。这是因为游戏结果判断逻辑有问题，没有正确考虑水晶的状态。

### 问题分析
1. 在 `BattleManager.ts` 中，`checkBattleResult` 方法正确地将水晶被摧毁判断为失败（`BattleResult.DEFEAT`）
2. 但在 `BattleEngine.ts` 中，`getResult` 方法只检查了英雄是否存活，没有考虑水晶的状态
3. 这导致即使水晶被摧毁，只要英雄还活着，游戏仍然显示胜利

### 修复方案
1. 修改 `BattleEngine.ts` 中的 `getResult` 方法，使用 `BattleManager` 的结果，而不是自己判断
2. 修改 `EventHandlers.ts` 中的 `onGameOver` 方法，确保正确处理游戏结果

### 修改的文件
1. `src/Battle/Core/BattleEngine.ts`
   - 修改 `getResult` 方法，使用 `getBattleResult` 获取战斗管理器的结果
   - 添加日志输出，便于调试

2. `src/Battle/View/EventHandlers.ts`
   - 修改 `onGameOver` 方法，确保结果是正确的
   - 添加日志输出，便于调试

### 修复效果
修复后，当水晶被摧毁时，游戏会正确显示失败，而不是胜利。这使得游戏逻辑更加合理，玩家体验更好。

## 修复豆豆被击杀后没有在视图层移除的问题

### 问题描述
当豆豆被英雄攻击并击杀后，豆豆在逻辑层已经被标记为死亡（日志显示"目标不存在或已死亡，清除目标"），但在视图层没有被正确移除，导致豆豆的图像仍然显示在屏幕上。

### 问题分析
通过分析代码，发现以下几个问题：
1. 当豆豆被击杀时，BattleManager触发了'entityDeath'事件，但EventHandlers中没有对应的处理方法
2. EntityRenderer中的playDeathAnimation方法负责播放死亡动画并从视图中移除实体，但这个方法没有被正确调用
3. 事件系统中的事件类型不一致，导致事件没有被正确处理

### 解决方案
1. 在EventHandlers中添加对entityDeath事件的处理方法onEntityDeath
2. 确保BattleManager在豆豆死亡时同时触发EventType.ENTITY_DEATH和字符串版本的'entityDeath'事件
3. 增强EntityRenderer中的playDeathAnimation方法，添加更多的视觉效果和日志记录

### 修改的文件
1. `src/Battle/View/EventHandlers.ts`
   - 添加对EventType.ENTITY_DEATH和'entityDeath'事件的监听
   - 添加onEntityDeath方法，处理实体死亡事件
   - 确保方法能够正确获取实体ID并调用playDeathAnimation方法

2. `src/Battle/Core/BattleManager.ts`
   - 修改豆豆死亡时的事件触发代码，同时使用EventType.ENTITY_DEATH和字符串版本的'entityDeath'
   - 确保事件数据格式正确，包含必要的entityId字段

3. `src/Battle/View/EntityRenderer.ts`
   - 增强playDeathAnimation方法，添加更多的视觉效果
   - 添加详细的日志记录，便于调试
   - 确保在动画完成后正确移除实体精灵和屏幕外指示器

### 效果
修改后，当豆豆被击杀时，不仅在逻辑层被标记为死亡，还会在视图层播放死亡动画并被正确移除。玩家可以看到豆豆死亡时的爆炸效果，并且屏幕上不再显示已死亡的豆豆。

### 后续工作
1. 考虑添加更多类型的死亡动画，根据豆豆类型显示不同的效果
2. 考虑添加死亡音效，增强游戏体验
3. 考虑优化事件系统，使用更统一的事件类型定义

## 增强豆豆被攻击时的日志记录

### 问题描述
在调试和分析游戏过程中，发现豆豆被攻击时的日志记录不够详细，难以追踪豆豆的生命值变化和伤害计算过程。这导致在排查豆豆相关问题时缺乏足够的信息。

### 问题分析
通过代码审查，发现以下几个问题：
1. 实体受到伤害时的日志级别为debug，不容易在日志中找到
2. 伤害计算过程缺乏详细的日志记录
3. 豆豆死亡时的日志不够详细，缺少豆豆类型、位置等信息
4. 不同类型豆豆的死亡效果没有明确的日志记录

### 解决方案
1. 在Entity类的takeDamage方法中，为豆豆类型的实体添加info级别的日志
2. 在DamageManager类的applyDamage方法中，为豆豆类型的目标添加更详细的info日志
3. 增强Bean类的onDeath方法，添加更详细的死亡信息，包括豆豆类型、位置、波次等
4. 为不同类型的豆豆添加特定的死亡效果日志

### 修改的文件
1. `src/Battle/Entities/Entity.ts`
   - 修改takeDamage方法，为豆豆类型添加info级别日志
   - 记录豆豆受到伤害前后的生命值变化

2. `src/Battle/Core/DamageManager.ts`
   - 修改applyDamage方法，为豆豆类型添加更详细的info日志
   - 记录豆豆受到伤害的类型、数量、暴击情况等
   - 记录豆豆的剩余生命值百分比

3. `src/Battle/Entities/Bean.ts`
   - 增强onDeath方法，添加更详细的死亡信息
   - 记录豆豆类型、位置、波次、击杀者等信息
   - 为不同类型的豆豆添加特定的死亡效果日志

### 效果
修改后，豆豆被攻击和死亡时的日志记录更加详细，包括：
1. 豆豆受到伤害的详细信息：伤害类型、数量、暴击情况等
2. 豆豆生命值的变化：从多少减少到多少，剩余百分比
3. 豆豆死亡的详细信息：豆豆类型、位置、波次、击杀者等
4. 不同类型豆豆的特定死亡效果

这些增强的日志记录有助于更好地调试和分析游戏过程，特别是在排查豆豆相关问题时。

### 后续工作
1. 考虑为其他类型的实体（如英雄、水晶）也添加类似的详细日志记录
2. 考虑添加日志过滤功能，允许只查看特定类型的日志
3. 考虑将关键日志保存到单独的文件，便于后续分析

## 修复英雄没有自动选择攻击目标的问题

### 问题描述
英雄没有自动选择攻击目标，导致英雄在战斗中不会主动攻击豆豆。

### 问题原因
1. 在BattleManager的updateHeroAI方法中，没有确保英雄设置了伤害管理器和实体管理器
2. 在processAttackCommand方法中，只有在英雄没有目标时才会设置伤害管理器和实体管理器

### 解决方案
1. 修改BattleManager.ts中的updateHeroAI方法，确保每个英雄都设置了伤害管理器和实体管理器
2. 修改processAttackCommand方法，无论英雄是否有目标，都设置伤害管理器和实体管理器

### 修改内容
1. 在updateHeroAI方法中，为每个英雄设置伤害管理器和实体管理器：
```typescript
// 遍历所有英雄
for (const hero of this.heroes.values()) {
  // 如果英雄存活，确保设置了伤害管理器和实体管理器，然后更新AI
  if (hero.isAlive()) {
    // 确保英雄设置了伤害管理器和实体管理器
    hero.setDamageManager(this.damageManager);
    hero.setEntityManager(this.entityManager);

    // 更新AI
    this.heroAI.update(hero);
  }
}
```

2. 在processAttackCommand方法中，始终设置伤害管理器和实体管理器：
```typescript
// 始终设置伤害管理器和实体管理器，确保英雄可以正常攻击
hero.setDamageManager(this.damageManager);
hero.setEntityManager(this.entityManager);
```

### 测试方法
1. 启动游戏，进入战斗场景
2. 观察英雄是否会自动选择攻击目标并攻击豆豆

## 修复暂停蒙层显示问题

### 问题描述
刚进入战斗场景时，暂停蒙层不应该显示，但目前暂停蒙层在战斗开始时就显示出来了，影响了游戏体验。

### 问题原因
1. 在UIManager.ts中，暂停覆盖层在创建时已经设置为隐藏（setVisible(false)），但没有设置透明度为0
2. 在fixUIElements方法中，没有正确处理暂停覆盖层的可见性和透明度
3. 在createUI方法中，没有明确设置暂停覆盖层的可见性和透明度

### 解决方案
1. 修改UIManager.ts中的fixUIElements方法，确保暂停覆盖层的透明度为0，并且设置为不可见
2. 修改createUI方法，添加额外的代码，确保暂停覆盖层初始时是隐藏的，并且透明度为0

### 修改内容
1. 在fixUIElements方法中，修改暂停覆盖层的初始化代码：
```typescript
// 固定暂停覆盖层
if (this.pauseOverlay) {
  this.pauseOverlay.setScrollFactor(0);
  this.pauseOverlay.setDepth(DepthLayers.UI_OVERLAY);
  // 初始时隐藏覆盖层，确保游戏开始时不显示暂停蒙层
  this.pauseOverlay.setVisible(false);
  this.pauseOverlay.setAlpha(0); // 设置透明度为0
  console.log('[INFO] 固定暂停覆盖层成功，初始状态：隐藏');
}
```

2. 在createUI方法中，添加额外的代码，确保暂停覆盖层初始时是隐藏的：
```typescript
// 确保暂停覆盖层初始时是隐藏的
if (this.pauseOverlay) {
  this.pauseOverlay.setVisible(false);
  this.pauseOverlay.setAlpha(0);
  console.log('[INFO] 确保暂停覆盖层初始时隐藏');
}
```

### 测试方法
1. 启动游戏，进入战斗场景
2. 观察暂停蒙层是否在战斗开始时隐藏
3. 点击暂停按钮，观察暂停蒙层是否正常显示
4. 点击继续按钮，观察暂停蒙层是否正常隐藏

## 优化英雄自动选择目标功能

### 问题描述
英雄需要自动选择最近的豆豆作为攻击目标，并且当当前目标不在攻击范围内时，需要自动切换到最近的目标。

### 问题分析
1. 当前的英雄AI系统已经有基础的目标选择功能，但没有考虑攻击范围
2. 当目标超出攻击范围时，英雄不会自动切换到更近的目标
3. 英雄AI的类型处理不够严谨，没有正确处理Hero类型

### 解决方案
1. 修改`HeroAI.ts`文件，优化目标选择逻辑
2. 在`selectTargetForHero`方法中，优先选择在攻击范围内的最近豆豆
3. 在`update`方法中，当当前目标不在攻击范围内时，自动切换到最近的目标
4. 确保正确处理`Hero`类型，使用类型转换和类型检查
5. 使用`EntityType`枚举而不是字符串字面量

### 修改内容
1. 导入`Hero`类和`EntityType`枚举：
```typescript
import { Entity, EntityType } from '../Entities/Entity';
import { Hero } from '../Entities/Hero';
```

2. 修改`selectTargetForHero`方法，优先选择在攻击范围内的最近豆豆：
```typescript
public selectTargetForHero(entity: Entity): string | null {
  // 确保实体是英雄类型
  if (entity.getType() !== EntityType.HERO) {
    logger.warn(`尝试为非英雄实体${entity.getId()}选择目标`);
    return null;
  }

  // 将实体转换为Hero类型
  const hero = entity as Hero;

  // 获取英雄位置和攻击范围
  const heroPosition = hero.getPosition();
  const attackRange = hero.getAttackRange();

  // 获取所有豆豆并按距离排序
  const beans = this.getAllBeans();
  const sortedBeans = this.sortBeansByDistance(beans, heroPosition);

  // 优先选择在攻击范围内的最近豆豆
  const inRangeBean = sortedBeans.find(bean => bean.distance <= attackRange);

  if (inRangeBean) {
    logger.info(`英雄${hero.getId()}自动选择攻击范围内的目标: ${inRangeBean.id}`);
    return inRangeBean.id;
  }

  // 如果没有在攻击范围内的豆豆，选择最近的豆豆
  if (sortedBeans.length > 0) {
    const closestBean = sortedBeans[0];
    logger.info(`英雄${hero.getId()}自动选择最近的目标: ${closestBean.id}`);
    return closestBean.id;
  }

  return null;
}
```

3. 修改`update`方法，当目标不在攻击范围内时自动切换目标：
```typescript
public update(entity: Entity): void {
  // 确保实体是英雄类型
  if (entity.getType() !== EntityType.HERO) {
    logger.warn(`尝试为非英雄实体${entity.getId()}更新AI`);
    return;
  }

  // 将实体转换为Hero类型
  const hero = entity as Hero;

  // 检查英雄是否有目标
  const currentTarget = hero.getTargetId();

  // 如果没有目标，选择一个新目标
  if (!currentTarget) {
    const newTarget = this.selectTargetForHero(hero);
    if (newTarget) {
      hero.setTargetId(newTarget);
      logger.info(`英雄${hero.getId()}AI设置新目标: ${newTarget}`);
    }
  } else {
    // 检查当前目标是否还存在且存活
    const targetEntity = this.entityManager.getEntity(currentTarget);
    if (!targetEntity || !targetEntity.isAlive()) {
      // 目标不存在或已死亡，清除目标并选择新目标
      hero.setTargetId(null);
      const newTarget = this.selectTargetForHero(hero);
      if (newTarget) {
        hero.setTargetId(newTarget);
        logger.info(`英雄${hero.getId()}AI更新目标: ${currentTarget} -> ${newTarget}`);
      }
    } else {
      // 目标存在且存活，检查是否在攻击范围内
      const heroPosition = hero.getPosition();
      const targetPosition = targetEntity.getPosition();
      const distance = Vector2DUtils.distance(heroPosition, targetPosition);
      const attackRange = hero.getAttackRange();

      // 如果目标不在攻击范围内，选择新的最近目标
      if (distance > attackRange) {
        logger.debug(`目标${currentTarget}超出攻击范围，距离: ${distance}, 攻击范围: ${attackRange}`);

        // 获取所有豆豆并按距离排序
        const beans = this.getAllBeans();
        if (beans.length > 0) {
          const sortedBeans = this.sortBeansByDistance(beans, heroPosition);

          // 找到在攻击范围内的最近豆豆
          const nearestInRange = sortedBeans.find(bean => bean.distance <= attackRange);

          if (nearestInRange && nearestInRange.id !== currentTarget) {
            // 如果找到在范围内的新目标，切换到该目标
            hero.setTargetId(nearestInRange.id);
            logger.info(`英雄${hero.getId()}切换到攻击范围内的新目标: ${currentTarget} -> ${nearestInRange.id}`);
          } else if (sortedBeans.length > 0 && sortedBeans[0].id !== currentTarget) {
            // 如果没有在范围内的目标，但有更近的目标，切换到最近的目标
            hero.setTargetId(sortedBeans[0].id);
            logger.info(`英雄${hero.getId()}切换到最近的新目标: ${currentTarget} -> ${sortedBeans[0].id}`);
          }
        }
      }
    }
  }
}
```

4. 修改`getAllBeans`方法，使用`EntityType.BEAN`枚举：
```typescript
private getAllBeans(): Entity[] {
  // 获取所有实体
  const allEntities = this.entityManager.getAllEntities();

  // 过滤出豆豆类型的实体
  return allEntities.filter(entity => {
    return entity.getType() === EntityType.BEAN && entity.isAlive();
  });
}
```

### 测试结果
修改完成后，英雄现在能够：
1. 自动选择最近的豆豆作为攻击目标
2. 优先选择在攻击范围内的豆豆
3. 当当前目标不在攻击范围内时，自动切换到最近的目标

这些改进使得英雄在战斗中更加智能，能够更有效地攻击豆豆。
