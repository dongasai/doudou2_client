# 2025-05-04 修复BUG

## 修复豆豆出生位置离水晶过近的问题

### 问题描述
战斗中，豆豆出生的位置离水晶过近，导致豆豆一出生就可以立即攻击水晶，没有给玩家足够的反应时间。

### 解决方案
1. 修改了WaveManager.ts中的spawnRange默认值，将最小距离从500增加到800，最大距离从800增加到1200。
2. 在BattleManager.ts中添加了对WaveManager的setSpawnRange方法的调用，确保豆豆生成在离水晶足够远的位置。
3. 修改了测试代码Hero1Stage1Scenario.js中的豆豆生成距离，从250增加到800。
4. 修改了BattleSceneView.ts中默认豆豆生成的位置计算方式，使用极坐标方式在水晶周围800单位的圆环上生成豆豆。

### 修改的文件
1. src/Battle/Core/WaveManager.ts
2. src/Battle/Core/BattleManager.ts
3. src/Battle/Test/Hero1Stage1Scenario.js
4. src/Battle/View/BattleSceneView.ts

### 效果
修改后，豆豆将在距离水晶800-1200单位的环形区域内生成，给玩家足够的反应时间来防御豆豆的攻击。

## 使用豆豆配置中的emoji字段

### 问题描述
在战斗场景中，豆豆的表情符号(emoji)是硬编码的，没有使用豆豆配置中的emoji字段，导致不同类型的豆豆显示相同的表情符号。

### 解决方案
通过事件系统传递豆豆的emoji信息，而不是在EntityRenderer中直接读取ConfigManager：
1. 修改EntityCreatedEventData和EntityCreatedEvent接口，添加emoji字段
2. 在BattleManager中创建豆豆时，从ConfigManager获取emoji信息并添加到事件数据中
3. 修改EntityRenderer中的代码，直接使用事件中传递的emoji信息
4. 修改BattleSceneView中的豆豆创建代码，添加emoji字段

### 修改的文件
1. src/Battle/Types/EventData.ts
2. src/Event/b2v/EntityCreated.ts
3. src/Battle/Core/BattleManager.ts
4. src/Battle/View/EntityRenderer.ts
5. src/Battle/View/BattleSceneView.ts

### 效果
修改后，不同类型的豆豆将显示不同的表情符号，使战斗场景更加生动有趣，也便于玩家区分不同类型的豆豆。同时，通过事件系统传递emoji信息，降低了组件间的耦合度，使代码更加清晰和可维护。

## 增加豆豆ID字段

### 问题描述
在敌人生成事件中，需要添加豆豆ID字段，以便在整个生成过程中保持ID的一致性。

### 解决方案
1. 修改EnemySpawnEventData接口，添加beanId字段
2. 修改WaveManager.ts中的spawnEnemyOfType方法，生成豆豆ID并添加到事件数据中
3. 修改BattleManager.ts中的registerWaveManagerEvents方法，传递豆豆ID
4. 修改BattleManager.ts中的createBeanFromWaveManager方法，使用传入的豆豆ID

### 修改的文件
1. src/Battle/Types/EventData.ts
2. src/Battle/Core/WaveManager.ts
3. src/Battle/Core/BattleManager.ts

### 效果
修改后，豆豆ID在整个生成过程中保持一致，从WaveManager生成到BattleManager创建，使用同一个ID，便于跟踪和调试。

## 使用豆豆表的ID

### 问题描述
在关卡配置文件中，豆豆类型使用中文名称，不够规范，应该使用豆豆表中的ID。

### 解决方案
1. 修改src/DesignConfig/Level.ts中的豆豆类型定义，将type字段的类型从string改为string | number
2. 修改public/DesignConfig/level-1/目录下所有关卡配置文件中的豆豆类型，将中文名称替换为豆豆ID：
   - 暴躁豆 -> 1
   - 毒豆 -> 2
   - 铁甲豆 -> 3
   - 闪电豆 -> 4
   - 分裂豆 -> 5
   - 冰霜豆 -> 6
   - 炸弹豆 -> 7
   - 治疗豆 -> 8
   - 暗影豆 -> 9
   - 岩石豆 -> 10
   - 旋风豆 -> 11
   - 幻象豆 -> 12
   - 火焰豆 -> 13
   - 荆棘豆 -> 14
   - 音波豆 -> 15
   - 吸血豆 -> 16
   - 磁力豆 -> 17
   - 剧毒豆 -> 18
   - 狂暴豆 -> 19
   - 幽灵豆/豆豆王 -> 20
3. 修改WaveManager.ts中的spawnEnemyOfType和spawnSpecialEnemy方法，支持数字类型的豆豆ID
4. 修改BattleManager.ts中的createBeanFromWaveManager方法，支持根据数字ID获取豆豆配置
5. 修改BattleParamsService.ts中的getDefaultBattleParams方法，使用数字ID替换中文名称

### 修改的文件
1. src/DesignConfig/Level.ts
2. public/DesignConfig/level-1/level-1-1.json
3. public/DesignConfig/level-1/level-1-2.json
4. public/DesignConfig/level-1/level-1-3.json
5. public/DesignConfig/level-1/level-1-4.json
6. public/DesignConfig/level-1/level-1-5.json
7. public/DesignConfig/level-1/level-1-6.json
8. public/DesignConfig/level-1/level-1-7.json
9. public/DesignConfig/level-1/level-1-8.json
10. public/DesignConfig/level-1/level-1-9.json
11. public/DesignConfig/level-1/level-1-10.json
12. src/Battle/Core/WaveManager.ts
13. src/Battle/Core/BattleManager.ts
14. src/services/BattleParamsService.ts

### 效果
修改后，关卡配置文件中使用豆豆表的ID来指定豆豆类型，更加规范和统一，也便于后续扩展和维护。同时，代码中也能够正确处理数字类型的豆豆ID，从ConfigManager中获取对应的豆豆配置。这样的设计更加灵活，也更容易与后端数据对接。

## 匹配CharacterBean接口与豆豆配置表

### 问题描述
在代码中，CharacterBean接口与豆豆配置表的结构不完全匹配，导致类型不一致的问题。同时，ConfigManager中使用了Bean类型，但实际上应该使用CharacterBean类型。

### 解决方案
1. 修改CharacterBean接口，使其与豆豆配置表完全匹配：
   - 将position字段改为可选字段
   - 改进emoji字段的注释，使其更加清晰
2. 修改ConfigManager.ts中的类型定义：
   - 将beansConfig的类型从Bean[]改为CharacterBean[]
   - 将getBeansConfig方法的返回类型从Bean[]改为CharacterBean[]
   - 将getBeanConfigById方法的返回类型从Bean改为CharacterBean
   - 删除对Bean接口的引用

### 修改的文件
1. src/DesignConfig/CharacterBean.ts
2. src/Managers/ConfigManager.ts

### 效果
修改后，CharacterBean接口与豆豆配置表完全匹配，消除了类型不一致的问题。同时，ConfigManager中使用了正确的类型定义，使代码更加清晰和可维护。这样的设计更加规范，也更容易进行类型检查和调试。

## 修复战斗场景中技能初始状态问题

### 问题描述
刚进入战斗场景时，技能处于点击状态，显示了技能描述。这不是预期的行为，技能应该默认处于未选中状态，技能描述应该隐藏。

### 根本原因分析
经过分析，发现问题的根本原因是代码中使用了鼠标事件（pointerover/pointerout）来处理技能提示的显示和隐藏，但这是一个手机游戏，没有鼠标悬停的概念。在触摸设备上，这些事件的行为与鼠标不同，导致技能提示框在初始状态下被错误地显示出来。

### 解决方案
1. 重新设计技能交互逻辑，使其适合触摸设备
2. 修改 `SkillUIComponent` 类，确保提示框初始状态为隐藏，并改用点击切换显示/隐藏状态
3. 修改 `TouchController` 类，添加逻辑处理技能选择和取消选择
4. 修改 `UIManager` 类，添加获取所有技能UI组件的方法
5. 修改 `BattleSceneView` 类，添加确保技能提示框隐藏的方法

### 修改详情

#### 1. 修改 SkillUIComponent 类
- 移除鼠标悬停（pointerover）和离开（pointerout）事件处理
- 改用点击（pointerdown）事件切换技能选中状态和提示框显示状态
- 添加对 `skillDeselected` 事件的监听，用于在选择其他技能时取消当前技能的选择
- 添加 `getTooltip` 方法，用于获取提示框容器

#### 2. 修改 TouchController 类
- 添加 `onSkillDeselected` 方法，处理技能取消选择事件
- 修改 `onSkillSelected` 方法，避免重复选择同一技能
- 添加对 `skillDeselected` 事件的监听
- 修改 `destroy` 方法，确保移除所有事件监听

#### 3. 修改 UIManager 类
- 添加 `getAllSkillUIComponents` 方法，用于获取所有技能UI组件

#### 4. 修改 BattleSceneView 类
- 添加 `ensureSkillTooltipsHidden` 方法，确保所有技能提示框都是隐藏的
- 在初始化时调用该方法，确保技能提示框初始状态正确

### 修改的文件
1. src/Battle/View/SkillUIComponent.ts
2. src/Battle/View/TouchController.ts
3. src/Battle/View/UIManager.ts
4. src/Battle/View/BattleSceneView.ts

### 效果
修复后，进入战斗场景时，技能按钮处于未选中状态，技能描述不会显示。用户点击技能按钮时，会显示技能描述并选中该技能。再次点击同一个技能按钮，会取消选择并隐藏技能描述。这种交互方式更适合触摸设备，提供了更好的用户体验。

## 优化UI交互适配触摸设备

### 问题描述
游戏中的多个UI组件使用了鼠标悬停（pointerover）和离开（pointerout）事件来处理交互效果，但这是一个手机游戏，没有鼠标悬停的概念。在触摸设备上，这些事件的行为与鼠标不同，导致交互体验不佳。

### 根本原因分析
代码中大量使用了PC端常见的鼠标悬停效果，如按钮在鼠标悬停时改变颜色，但在触摸设备上，用户只能点击而不能悬停，导致这些效果无法正常工作。

### 解决方案
1. 重新设计UI交互逻辑，使其适合触摸设备
2. 移除所有鼠标悬停（pointerover）和离开（pointerout）事件处理
3. 改用点击（pointerdown）事件提供视觉反馈，并添加短暂延迟后执行操作
4. 为按钮点击添加颜色变化或高亮效果，提供更好的触摸反馈

### 修改详情

#### 1. 修改 UIManager 类中的按钮
- 修改暂停按钮，移除悬停效果，改用点击时改变背景色并添加短暂延迟
- 修改波次完成提示中的继续按钮，添加点击反馈效果
- 修改游戏结束提示中的返回按钮，添加点击反馈效果

#### 2. 修改 MainMenuScene 类中的按钮
- 修改开始游戏按钮，移除悬停效果，改用点击时添加高亮效果并添加短暂延迟
- 修改快速开始按钮，添加类似的点击反馈效果
- 修改百科按钮，添加点击反馈效果
- 修改设置按钮，添加点击反馈效果
- 修改制作人员按钮，添加点击反馈效果
- 修改设置面板中的关闭按钮和保存按钮，添加点击反馈效果
- 修改制作人员面板中的关闭按钮，添加点击反馈效果

#### 3. 修改 LevelSelectScene 类中的按钮
- 修改关卡选择按钮，移除悬停效果，改用点击时改变颜色并添加短暂延迟

### 修改的文件
1. src/Battle/View/UIManager.ts
2. src/Scenes/MainMenuScene.ts
3. src/Scenes/LevelSelectScene.ts

### 效果
修改后，所有UI按钮都提供了更适合触摸设备的交互体验：
1. 点击按钮时会立即提供视觉反馈（颜色变化或高亮效果）
2. 短暂延迟后执行操作，让用户能够看到按钮状态变化
3. 移除了所有依赖鼠标悬停的效果，使游戏在触摸设备上有更一致的体验
4. 按钮响应更加明确，用户能够清楚地知道自己的触摸操作是否被正确识别
