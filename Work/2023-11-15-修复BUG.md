# 2023-11-15 修复BUG日志

## 问题描述
1. 水晶状态存在但精灵不存在，可能是实体创建事件未被正确处理。
2. 英雄不显示，可能是相同的原因导致英雄创建事件未被正确处理。
3. 水晶状态显示为 `{hp: undefined, maxHp: undefined}`，导致生命值条无法正确显示。

## 问题分析
通过代码分析，发现以下几个问题：

1. **事件监听器绑定问题**：在`BattleSceneView`类中，使用`this.onEntityCreated.bind(this)`方式注册事件监听器，但在移除监听器时也使用了`this.onEntityCreated.bind(this)`，这会创建一个新的函数引用，导致无法正确移除原来注册的监听器。具体来说，每次调用`.bind(this)`都会创建一个新的函数引用，即使绑定的方法和上下文相同。这导致注册和移除事件监听器时使用的不是同一个函数引用，从而无法正确移除监听器。

2. **类型不匹配问题**：在`BattleInitParams`接口中，水晶的属性使用的是`currentHP`和`maxHP`（大写），而在`EntityStats`接口中使用的是`hp`和`maxHp`（小写）。这导致在创建水晶时，如果直接使用配置中的属性，可能会出现属性名不匹配的情况。

3. **空值处理问题**：在`BattleManager.getBattleStats`方法中，获取水晶状态时没有处理`hp`和`maxHp`为undefined的情况，导致返回的水晶状态中包含undefined值。同样，在`BattleSceneView.updateHealthBar`方法中，也没有处理`currentHp`和`maxHp`为undefined或NaN的情况。

## 解决方案
1. **修复事件监听器绑定问题**：
   - 在`BattleSceneView`类中添加一个`boundEventHandlers`映射，用于保存绑定后的事件处理器。
   - 修改`registerEventListeners`方法，使用一个辅助函数`bindEventHandler`来绑定事件处理器并保存到映射中。
   - 修改`destroy`方法，使用保存的绑定处理器来移除事件监听器。

2. **添加自动恢复机制**：
   - 在`updateEntities`方法中添加自动恢复机制，当检测到实体状态存在但精灵不存在时，尝试重新创建实体精灵（包括水晶和英雄）。

3. **修复水晶状态undefined问题**：
   - 在`BattleManager.createCrystal`方法中添加代码，确保正确设置水晶的hp和maxHp。
   - 在`BattleManager.getBattleStats`方法中添加空值处理，确保返回的水晶状态中不包含undefined值。
   - 在`BattleSceneView.updateHealthBar`方法中添加参数检查，确保能够处理undefined或NaN的hp和maxHp值。

4. **添加调试日志**：
   - 添加更多调试日志，以便更好地跟踪事件流程和状态变化。

## 修改的文件
- `src/Battle/View/BattleSceneView.ts`
- `src/Battle/Core/BattleManager.ts`

## 具体修改
1. 添加`boundEventHandlers`映射：
```typescript
// 绑定的事件处理器
private boundEventHandlers: Map<string, EventHandler<any>> = new Map();
```

2. 修改`registerEventListeners`方法：
```typescript
private registerEventListeners(): void {
  // 创建并保存绑定的事件处理器
  const bindEventHandler = <T>(eventType: string, handler: (event: T) => void): void => {
    const boundHandler: EventHandler<T> = handler.bind(this);
    this.boundEventHandlers.set(eventType, boundHandler);
    this.eventManager.on(eventType, boundHandler);
    console.log(`[DEBUG] 注册事件监听: ${eventType}`);
  };

  // 监听实体创建事件
  bindEventHandler(EventType.ENTITY_CREATED, this.onEntityCreated);

  // ... 其他事件监听器 ...
}
```

3. 修改`destroy`方法：
```typescript
public destroy(): void {
  // 移除事件监听
  console.log('[DEBUG] 开始移除事件监听器...');

  // 使用保存的绑定处理器移除事件监听
  for (const [eventType, handler] of this.boundEventHandlers.entries()) {
    this.eventManager.off(eventType, handler);
    console.log(`[DEBUG] 移除事件监听: ${eventType}`);
  }

  // 清空绑定处理器映射
  this.boundEventHandlers.clear();
  console.log('[DEBUG] 所有事件监听器已移除');

  // ... 其他清理代码 ...
}
```

4. 在`updateEntities`方法中添加实体精灵自动恢复机制：

```typescript
// 更新英雄
if (battleStats.heroStats) {
  console.log('[DEBUG] 检测到英雄状态:', battleStats.heroStats);

  for (const hero of battleStats.heroStats) {
    const sprite = this.entitySprites.get(hero.id);
    if (sprite) {
      // 更新位置和生命值条...
      console.log('[DEBUG] 英雄精灵存在，已更新位置和生命值条:', hero.id);
    } else {
      // 如果英雄精灵不存在但有英雄状态，记录日志
      console.log('[DEBUG] 英雄状态存在但精灵不存在，可能是实体创建事件未被正确处理:', hero.id);

      // 检查事件监听器是否正确注册
      console.log('[DEBUG] ENTITY_CREATED 事件监听器数量:',
        this.eventManager.listenerCount ? this.eventManager.listenerCount(EventType.ENTITY_CREATED) : '无法获取');

      // 尝试重新创建英雄精灵
      try {
        // 创建英雄精灵代码...
      } catch (error) {
        console.error('[ERROR] 重新创建英雄精灵失败:', error);
      }
    }
  }
}

// 水晶精灵自动恢复机制：
```
// 更新水晶
if (battleStats.crystalStats) {
  console.log('[DEBUG] 检测到水晶状态:', battleStats.crystalStats);
  const sprite = this.entitySprites.get('crystal_1');
  if (sprite) {
    // 更新生命值条
    this.updateHealthBar('crystal_1', battleStats.crystalStats.hp, battleStats.crystalStats.maxHp);
    console.log('[DEBUG] 水晶精灵存在，已更新生命值条');
  } else {
    // 如果水晶精灵不存在但有水晶状态，记录日志
    console.log('[DEBUG] 水晶状态存在但精灵不存在，可能是实体创建事件未被正确处理');
    console.log('[DEBUG] 当前所有实体精灵:', Array.from(this.entitySprites.keys()));
    console.log('[DEBUG] 尝试重新创建水晶精灵...');

    // 尝试重新创建水晶精灵
    try {
      const screenWidth = this.scene.cameras.main.width;
      const position = { x: 1500, y: 1500 }; // 水晶的默认位置
      const screenPos = this.worldToScreenPosition(position);
      const heroSize = Math.min(48, Math.max(32, screenWidth * 0.09));

      // 创建水晶精灵
      const crystalSprite = this.scene.add.text(screenPos.x, screenPos.y, '💎', {
        fontSize: `${heroSize}px`
      });
      crystalSprite.setOrigin(0.5);

      // 添加到映射
      this.entitySprites.set('crystal_1', crystalSprite as any);

      // 创建生命值条
      const healthBar = this.scene.add.graphics();
      this.entityHealthBars.set('crystal_1', healthBar);

      // 更新生命值条
      this.updateHealthBar('crystal_1', battleStats.crystalStats.hp, battleStats.crystalStats.maxHp);

      console.log('[DEBUG] 水晶精灵重新创建成功');
    } catch (error) {
      console.error('[ERROR] 重新创建水晶精灵失败:', error);
    }
  }
}
```

5. 修复水晶状态undefined问题：

在`BattleManager.createCrystal`方法中添加代码，确保正确设置水晶的hp和maxHp：
```typescript
private createCrystal(crystalConfig: any): void {
  // 记录水晶配置
  console.log('[DEBUG] 水晶配置:', crystalConfig);

  // 确保水晶配置中有正确的HP值
  const maxHp = crystalConfig.maxHp || crystalConfig.maxHP || 1000;

  // 创建水晶实体
  this.crystal = new Crystal(
    'crystal_1',
    '水晶',
    { x: 1500, y: 1500 },
    {
      hp: maxHp,
      maxHp: maxHp
    },
    this.frameManager.getCurrentLogicFrame()
  );

  // ... 其他代码 ...

  // 验证水晶状态
  console.log('[DEBUG] 水晶创建后状态:', {
    hp: this.crystal.getStat('hp'),
    maxHp: this.crystal.getStat('maxHp')
  });
}
```

在`BattleManager.getBattleStats`方法中添加空值处理：
```typescript
public getBattleStats(): any {
  // ... 其他代码 ...

  return {
    // ... 其他属性 ...
    heroStats: Array.from(this.heroes.values()).map(hero => ({
      id: hero.getId(),
      name: hero.getName(),
      level: hero.getStat('level'),
      hp: hero.getStat('hp') ?? 0,
      maxHp: hero.getStat('maxHp') ?? 100,
      mp: hero.getStat('mp') ?? 0,
      maxMp: hero.getStat('maxMp') ?? 100,
      position: hero.getPosition()
    })),
    crystalStats: this.crystal ? {
      hp: this.crystal.getStat('hp') ?? 1000,
      maxHp: this.crystal.getStat('maxHp') ?? 1000
    } : null
  };
}
```

在`BattleSceneView.updateHealthBar`方法中添加参数检查：
```typescript
private updateHealthBar(entityId: string, currentHp: number, maxHp: number): void {
  // 检查参数有效性
  if (currentHp === undefined || isNaN(currentHp)) {
    console.warn(`[WARN] updateHealthBar: currentHp 无效 (${currentHp})，使用默认值 100`);
    currentHp = 100;
  }

  if (maxHp === undefined || isNaN(maxHp) || maxHp <= 0) {
    console.warn(`[WARN] updateHealthBar: maxHp 无效 (${maxHp})，使用默认值 100`);
    maxHp = 100;
  }

  // ... 其他代码 ...

  // 计算生命值比例
  const ratio = Math.max(0, Math.min(1, currentHp / maxHp));
  console.log(`[DEBUG] 更新生命值条: ${entityId}, HP=${currentHp}/${maxHp}, 比例=${ratio.toFixed(2)}`);
}
```

## 测试结果
修复后，水晶和英雄精灵能够正确显示，即使在某些情况下实体创建事件未被正确处理，也能通过自动恢复机制重新创建实体精灵。

## 总结
这个问题的根本原因是JavaScript中函数绑定的特性导致的。每次调用`.bind()`都会创建一个新的函数引用，即使绑定的方法和上下文相同。在事件系统中，这会导致无法正确移除事件监听器。

解决方案是保存绑定后的函数引用，并在注册和移除事件监听器时使用相同的引用。此外，添加自动恢复机制可以增强系统的健壮性，即使在出现问题的情况下也能保持正常运行。

## 后续改进建议
1. 考虑重构事件系统，使用更现代的事件处理方式，如发布-订阅模式或使用专门的事件库。
2. 添加更多的错误处理和恢复机制，提高系统的健壮性。
3. 考虑使用TypeScript的装饰器来简化事件绑定，避免手动管理函数引用。
4. 统一接口命名规范，避免类似hp/HP、maxHp/maxHP这样的不一致情况。
5. 减少调试日志，只保留关键的日志信息，提高性能和可读性。
